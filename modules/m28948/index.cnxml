<document xmlns="http://cnx.rice.edu/cnxml" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:md="http://cnx.rice.edu/mdml">
  <title>Transversal Equalizer</title>
  <metadata>
  <md:content-id>m28948</md:content-id><md:title>Transversal Equalizer</md:title>
  <md:abstract/>
  <md:uuid>a4b20ed6-af4b-4a6f-8fe1-946635bc77b3</md:uuid>
</metadata>

<content>
    <para id="id9783200"><term>Transversal Equalizer</term></para>
    <para id="id10753880"/>
    <para id="id11031529">A training sequence used for equalization is often chosen to be a noise-like sequence which is needed to estimate the channel frequency response.</para>
    <para id="id10467967"/>
    <para id="id8772920">In the simplest sense, training sequence might be a single narrow pulse, but a pseudonoise (PN) signal is preferred in practise because the PN signal has larger average power and hence larger SNR for the same peak transmitted power.</para>
    <para id="id11236407"/>
    <para id="id11308005">
      <media id="id6692269" alt=""><image src="../../media/graphics1-e3db.png" mime-type="image/png" height="227" width="577"/></media>
    </para>
    <para id="id10468537"/>
    <para id="id8729984"><emphasis>Figure 1</emphasis> Received pulse exhibiting distortion.</para>
    <para id="id10238056"/>
    <para id="id10298462">Consider that a single pulse was transmitted over a system designated to have a raised-cosine transfer function 
<m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:mrow><m:msub><m:mi>H</m:mi><m:mstyle fontsize="8pt"><m:mrow><m:mstyle fontstyle="italic"><m:mrow><m:mtext>RC</m:mtext></m:mrow></m:mstyle></m:mrow></m:mstyle></m:msub><m:mo stretchy="false">(</m:mo><m:mi>t</m:mi><m:mrow><m:mo stretchy="false">)</m:mo><m:mo stretchy="false">=</m:mo><m:msub><m:mi>H</m:mi><m:mstyle fontsize="8pt"><m:mrow><m:mi>t</m:mi></m:mrow></m:mstyle></m:msub></m:mrow><m:mo stretchy="false">(</m:mo><m:mi>f</m:mi><m:mo stretchy="false">)</m:mo><m:mtext>.</m:mtext><m:msub><m:mi>H</m:mi><m:mstyle fontsize="8pt"><m:mrow><m:mi>r</m:mi></m:mrow></m:mstyle></m:msub><m:mo stretchy="false">(</m:mo><m:mi>f</m:mi><m:mo stretchy="false">)</m:mo></m:mrow></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{H rSub { size 8{ ital "RC"} }  \( t \) =H rSub { size 8{t} }  \( f \)  "." H rSub { size 8{r} }  \( f \) } {}</m:annotation></m:semantics></m:math>, also consider that the channel induces ISI, so that the received demodulated pulse exhibits distortion, as shown in Figure 1, such that the pulse sidelobes do not go through zero at sample times. To achieve the desired raised-cosine transfer function, the equalizing filter should have a frequency response</para>
    <para id="id8754041"><m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:mrow><m:msub><m:mi>H</m:mi><m:mstyle fontsize="8pt"><m:mrow><m:mi>e</m:mi></m:mrow></m:mstyle></m:msub><m:mo stretchy="false">(</m:mo><m:mi>f</m:mi><m:mrow><m:mrow><m:mo stretchy="false">)</m:mo><m:mo stretchy="false">=</m:mo><m:mfrac><m:mn>1</m:mn><m:mrow><m:msub><m:mi>H</m:mi><m:mstyle fontsize="8pt"><m:mrow><m:mi>c</m:mi></m:mrow></m:mstyle></m:msub><m:mo stretchy="false">(</m:mo><m:mi>f</m:mi><m:mo stretchy="false">)</m:mo></m:mrow></m:mfrac></m:mrow><m:mo stretchy="false">=</m:mo><m:mfrac><m:mn>1</m:mn><m:mrow><m:mo stretchy="false">∣</m:mo><m:mrow><m:msub><m:mi>H</m:mi><m:mstyle fontsize="8pt"><m:mrow><m:mi>c</m:mi></m:mrow></m:mstyle></m:msub><m:mo stretchy="false">(</m:mo><m:mi>f</m:mi><m:mo stretchy="false">)</m:mo></m:mrow><m:mo stretchy="false">∣</m:mo></m:mrow></m:mfrac></m:mrow><m:msup><m:mi>e</m:mi><m:mstyle fontsize="8pt"><m:mrow><m:mrow><m:mrow><m:mo stretchy="false">−</m:mo><m:msub><m:mi fontstyle="italic">jθ</m:mi><m:mstyle fontsize="6pt"><m:mrow><m:mi>c</m:mi></m:mrow></m:mstyle></m:msub></m:mrow><m:mo stretchy="false">(</m:mo><m:mi>f</m:mi><m:mo stretchy="false">)</m:mo></m:mrow></m:mrow></m:mstyle></m:msup></m:mrow></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{H rSub { size 8{e} }  \( f \) = {  {1}  over  {H rSub { size 8{c} }  \( f \) } } = {  {1}  over  { lline H rSub { size 8{c} }  \( f \)  rline } } e rSup { size 8{ - jθ rSub { size 6{c} }  \( f \) } } } {}</m:annotation></m:semantics></m:math> (1)</para>
    <para id="id10827330">In other words, we would like the equalizing filter to generate a set of canceling echoes. The transversal filter, illustrated in Figure 2, is the most popular form of an easily adjustable equalizing filter consisting of a delay line with T-second taps (where T is the symbol duration). The tab weights could be chosen to force the system impulse response to zero at all but one of the sampling times, thus making 
<m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:mrow><m:msub><m:mi>H</m:mi><m:mstyle fontsize="8pt"><m:mrow><m:mi>e</m:mi></m:mrow></m:mstyle></m:msub><m:mo stretchy="false">(</m:mo><m:mi>f</m:mi><m:mo stretchy="false">)</m:mo></m:mrow></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{H rSub { size 8{e} }  \( f \) } {}</m:annotation></m:semantics></m:math> correspond exactly to the inverse of the channel transfer function 
<m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:mrow><m:msub><m:mi>H</m:mi><m:mstyle fontsize="8pt"><m:mrow><m:mi>c</m:mi></m:mrow></m:mstyle></m:msub><m:mo stretchy="false">(</m:mo><m:mi>f</m:mi><m:mo stretchy="false">)</m:mo></m:mrow></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{H rSub { size 8{c} }  \( f \) } {}</m:annotation></m:semantics></m:math></para>
    <figure id="id10469418">
      <media id="id6783204" alt=""><image src="../../media/graphics2-89b8.png" mime-type="image/png" height="322" width="286"/></media>
    </figure>
    <para id="id10583226"><emphasis>Figure 2</emphasis> Transversal filter</para>
    <para id="id10546334">Consider that there are 
<m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:mrow><m:mn>2N</m:mn><m:mo stretchy="false">+</m:mo><m:mn>1</m:mn></m:mrow></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{2N+1} {}</m:annotation></m:semantics></m:math> taps with weights 
<m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:mrow><m:msub><m:mi>c</m:mi><m:mstyle fontsize="8pt"><m:mrow><m:mrow><m:mo stretchy="false">−</m:mo><m:mi>N</m:mi></m:mrow></m:mrow></m:mstyle></m:msub><m:mi>,</m:mi><m:msub><m:mi>c</m:mi><m:mstyle fontsize="8pt"><m:mrow><m:mrow><m:mrow><m:mo stretchy="false">−</m:mo><m:mi>N</m:mi></m:mrow><m:mo stretchy="false">+</m:mo><m:mn>1</m:mn></m:mrow></m:mrow></m:mstyle></m:msub><m:mi>,</m:mi><m:mtext>.</m:mtext><m:mtext>.</m:mtext><m:mtext>.</m:mtext><m:msub><m:mi>c</m:mi><m:mstyle fontsize="8pt"><m:mrow><m:mi>N</m:mi></m:mrow></m:mstyle></m:msub></m:mrow></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{c rSub { size 8{ - N} } ,c rSub { size 8{ - N+1} } , "."  "."  "." c rSub { size 8{N} } } {}</m:annotation></m:semantics></m:math> . Output samples 
<m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:mrow><m:mi>z</m:mi><m:mo stretchy="false">(</m:mo><m:mi>k</m:mi><m:mo stretchy="false">)</m:mo></m:mrow></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{z \( k \) } {}</m:annotation></m:semantics></m:math> are the convolution the input sample 
<m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:mrow><m:mi>x</m:mi><m:mo stretchy="false">(</m:mo><m:mi>k</m:mi><m:mo stretchy="false">)</m:mo></m:mrow></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{x \( k \) } {}</m:annotation></m:semantics></m:math> and tap weights 
<m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:msub><m:mi>c</m:mi><m:mstyle fontsize="8pt"><m:mrow><m:mi>n</m:mi></m:mrow></m:mstyle></m:msub></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{c rSub { size 8{n} } } {}</m:annotation></m:semantics></m:math> as follows:</para>
    <para id="id9923216"><m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:mrow><m:mi>z</m:mi><m:mo stretchy="false">(</m:mo><m:mi>k</m:mi><m:mrow><m:mo stretchy="false">)</m:mo><m:mo stretchy="false">=</m:mo><m:mrow><m:munderover><m:mo stretchy="false">∑</m:mo><m:mstyle fontsize="8pt"><m:mrow><m:mrow><m:mi>n</m:mi><m:mo stretchy="false">=</m:mo><m:mrow><m:mo stretchy="false">−</m:mo><m:mi>N</m:mi></m:mrow></m:mrow></m:mrow></m:mstyle><m:mstyle fontsize="8pt"><m:mrow><m:mi>N</m:mi></m:mrow></m:mstyle></m:munderover><m:mrow><m:mi>x</m:mi><m:mo stretchy="false">(</m:mo><m:mrow><m:mi>k</m:mi><m:mo stretchy="false">−</m:mo><m:mi>n</m:mi></m:mrow><m:mo stretchy="false">)</m:mo><m:msub><m:mi>c</m:mi><m:mstyle fontsize="8pt"><m:mrow><m:mi>n</m:mi></m:mrow></m:mstyle></m:msub></m:mrow></m:mrow></m:mrow></m:mrow></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{z \( k \) = Sum cSub { size 8{n= - N} }  cSup { size 8{N} }  {x \( k - n \) c rSub { size 8{n} } } } {}</m:annotation></m:semantics></m:math><m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:mrow><m:mrow><m:mi>k</m:mi><m:mo stretchy="false">=</m:mo><m:mrow><m:mo stretchy="false">−</m:mo><m:mn>2N</m:mn></m:mrow></m:mrow><m:mi>,</m:mi><m:mtext>.</m:mtext><m:mtext>.</m:mtext><m:mtext>.</m:mtext><m:mn>2N</m:mn></m:mrow></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{k= - 2N, "."  "."  "." 2N} {}</m:annotation></m:semantics></m:math>(2)</para>
    <para id="id10857708">By defining the vectors z and c and the matrix x as respectively,</para>
    <para id="id9729482">
      <m:math>
        <m:semantics>
          <m:mrow>
            <m:mstyle fontsize="12pt">
              <m:mrow>
                <m:mrow>
                  <m:mi>z</m:mi>
                  <m:mo stretchy="false">=</m:mo>
                  <m:mfenced open="[" close="]">
                    <m:mtable>
                      <m:mtr>
                        <m:mtd>
                          <m:mrow>
                            <m:mi>z</m:mi>
                            <m:mrow>
                              <m:mo stretchy="false">(</m:mo>
                              <m:mo stretchy="false">−</m:mo>
                              <m:mn>2N</m:mn>
                            </m:mrow>
                            <m:mo stretchy="false">)</m:mo>
                            <m:mrow/>
                          </m:mrow>
                        </m:mtd>
                      </m:mtr>
                      <m:mtr>
                        <m:mtd>
                          <m:mrow>
                            <m:mo stretchy="false">⋮</m:mo>
                            <m:mrow/>
                          </m:mrow>
                        </m:mtd>
                      </m:mtr>
                      <m:mtr>
                        <m:mtd>
                          <m:mrow>
                            <m:mi>z</m:mi>
                            <m:mo stretchy="false">(</m:mo>
                            <m:mn>0</m:mn>
                            <m:mo stretchy="false">)</m:mo>
                            <m:mrow/>
                          </m:mrow>
                        </m:mtd>
                      </m:mtr>
                      <m:mtr>
                        <m:mtd>
                          <m:mrow>
                            <m:mo stretchy="false">⋮</m:mo>
                            <m:mrow/>
                          </m:mrow>
                        </m:mtd>
                      </m:mtr>
                      <m:mtr>
                        <m:mtd>
                          <m:mrow>
                            <m:mi>z</m:mi>
                            <m:mo stretchy="false">(</m:mo>
                            <m:mn>2N</m:mn>
                            <m:mo stretchy="false">)</m:mo>
                          </m:mrow>
                        </m:mtd>
                      </m:mtr>
                    </m:mtable>
                  </m:mfenced>
                </m:mrow>
              </m:mrow>
            </m:mstyle>
            <m:mrow/>
          </m:mrow>
          <m:annotation encoding="StarMath 5.0"> size 12{z= left [ matrix {
z \(  - 2N \)  {} ##
 dotsvert  {} ##
z \( 0 \)  {} ##
 dotsvert  {} ##
z \( 2N \) 
}  right ]} {}</m:annotation>
        </m:semantics>
      </m:math>
      <m:math>
        <m:semantics>
          <m:mrow>
            <m:mstyle fontsize="12pt">
              <m:mrow>
                <m:mrow>
                  <m:mi>c</m:mi>
                  <m:mo stretchy="false">=</m:mo>
                  <m:mfenced open="[" close="]">
                    <m:mtable>
                      <m:mtr>
                        <m:mtd>
                          <m:mrow>
                            <m:msub>
                              <m:mi>c</m:mi>
                              <m:mstyle fontsize="8pt">
                                <m:mrow>
                                  <m:mrow>
                                    <m:mo stretchy="false">−</m:mo>
                                    <m:mi>N</m:mi>
                                  </m:mrow>
                                </m:mrow>
                              </m:mstyle>
                            </m:msub>
                            <m:mo stretchy="false">)</m:mo>
                            <m:mrow/>
                          </m:mrow>
                        </m:mtd>
                      </m:mtr>
                      <m:mtr>
                        <m:mtd>
                          <m:mrow>
                            <m:mo stretchy="false">⋮</m:mo>
                            <m:mrow/>
                          </m:mrow>
                        </m:mtd>
                      </m:mtr>
                      <m:mtr>
                        <m:mtd>
                          <m:mrow>
                            <m:msub>
                              <m:mi>c</m:mi>
                              <m:mstyle fontsize="8pt">
                                <m:mrow>
                                  <m:mn>0</m:mn>
                                </m:mrow>
                              </m:mstyle>
                            </m:msub>
                            <m:mrow/>
                          </m:mrow>
                        </m:mtd>
                      </m:mtr>
                      <m:mtr>
                        <m:mtd>
                          <m:mrow>
                            <m:mo stretchy="false">⋮</m:mo>
                            <m:mrow/>
                          </m:mrow>
                        </m:mtd>
                      </m:mtr>
                      <m:mtr>
                        <m:mtd>
                          <m:msub>
                            <m:mi>c</m:mi>
                            <m:mstyle fontsize="8pt">
                              <m:mrow>
                                <m:mi>N</m:mi>
                              </m:mrow>
                            </m:mstyle>
                          </m:msub>
                        </m:mtd>
                      </m:mtr>
                    </m:mtable>
                  </m:mfenced>
                </m:mrow>
              </m:mrow>
            </m:mstyle>
            <m:mrow/>
          </m:mrow>
          <m:annotation encoding="StarMath 5.0"> size 12{c= left [ matrix {
c rSub { size 8{ - N} }  \)  {} ##
 dotsvert  {} ##
c rSub { size 8{0} }  {} ##
 dotsvert  {} ##
c rSub { size 8{N} } 
}  right ]} {}</m:annotation>
        </m:semantics>
      </m:math>
      <m:math>
        <m:semantics>
          <m:mrow>
            <m:mstyle fontsize="12pt">
              <m:mrow>
                <m:mrow>
                  <m:mi>x</m:mi>
                  <m:mo stretchy="false">=</m:mo>
                  <m:mfenced open="[" close="]">
                    <m:mtable>
                      <m:mtr>
                        <m:mtd>
                          <m:mrow>
                            <m:mi>x</m:mi>
                            <m:mrow>
                              <m:mo stretchy="false">(</m:mo>
                              <m:mo stretchy="false">−</m:mo>
                              <m:mi>N</m:mi>
                            </m:mrow>
                            <m:mo stretchy="false">)</m:mo>
                            <m:mrow/>
                          </m:mrow>
                        </m:mtd>
                        <m:mtd>
                          <m:mrow>
                            <m:mn>0</m:mn>
                            <m:mrow/>
                          </m:mrow>
                        </m:mtd>
                        <m:mtd>
                          <m:mrow>
                            <m:mn>0</m:mn>
                            <m:mrow/>
                          </m:mrow>
                        </m:mtd>
                        <m:mtd>
                          <m:mrow>
                            <m:mo stretchy="false">…</m:mo>
                            <m:mrow/>
                          </m:mrow>
                        </m:mtd>
                        <m:mtd>
                          <m:mrow>
                            <m:mn>0</m:mn>
                            <m:mrow/>
                          </m:mrow>
                        </m:mtd>
                        <m:mtd>
                          <m:mrow>
                            <m:mn>0</m:mn>
                            <m:mrow/>
                          </m:mrow>
                        </m:mtd>
                      </m:mtr>
                      <m:mtr>
                        <m:mtd>
                          <m:mrow>
                            <m:mi>x</m:mi>
                            <m:mrow>
                              <m:mrow>
                                <m:mo stretchy="false">(</m:mo>
                                <m:mo stretchy="false">−</m:mo>
                                <m:mi>N</m:mi>
                              </m:mrow>
                              <m:mo stretchy="false">+</m:mo>
                              <m:mn>1</m:mn>
                            </m:mrow>
                            <m:mo stretchy="false">)</m:mo>
                            <m:mrow/>
                          </m:mrow>
                        </m:mtd>
                        <m:mtd>
                          <m:mrow>
                            <m:mi>x</m:mi>
                            <m:mrow>
                              <m:mo stretchy="false">(</m:mo>
                              <m:mo stretchy="false">−</m:mo>
                              <m:mi>N</m:mi>
                            </m:mrow>
                            <m:mo stretchy="false">)</m:mo>
                            <m:mrow/>
                          </m:mrow>
                        </m:mtd>
                        <m:mtd>
                          <m:mrow>
                            <m:mn>0</m:mn>
                            <m:mrow/>
                          </m:mrow>
                        </m:mtd>
                        <m:mtd>
                          <m:mrow>
                            <m:mo stretchy="false">…</m:mo>
                            <m:mrow/>
                          </m:mrow>
                        </m:mtd>
                        <m:mtd>
                          <m:mrow>
                            <m:mo stretchy="false">…</m:mo>
                            <m:mrow/>
                          </m:mrow>
                        </m:mtd>
                        <m:mtd>
                          <m:mrow>
                            <m:mo stretchy="false">…</m:mo>
                            <m:mrow/>
                          </m:mrow>
                        </m:mtd>
                      </m:mtr>
                      <m:mtr>
                        <m:mtd>
                          <m:mrow>
                            <m:mo stretchy="false">⋮</m:mo>
                            <m:mrow/>
                          </m:mrow>
                        </m:mtd>
                        <m:mtd>
                          <m:mrow/>
                        </m:mtd>
                        <m:mtd>
                          <m:mrow/>
                        </m:mtd>
                        <m:mtd>
                          <m:mrow>
                            <m:mo stretchy="false">⋮</m:mo>
                            <m:mrow/>
                          </m:mrow>
                        </m:mtd>
                        <m:mtd>
                          <m:mrow/>
                        </m:mtd>
                        <m:mtd>
                          <m:mrow>
                            <m:mo stretchy="false">⋮</m:mo>
                            <m:mrow/>
                          </m:mrow>
                        </m:mtd>
                      </m:mtr>
                      <m:mtr>
                        <m:mtd>
                          <m:mrow>
                            <m:mi>x</m:mi>
                            <m:mo stretchy="false">(</m:mo>
                            <m:mi>N</m:mi>
                            <m:mo stretchy="false">)</m:mo>
                            <m:mrow/>
                          </m:mrow>
                        </m:mtd>
                        <m:mtd>
                          <m:mrow>
                            <m:mi>x</m:mi>
                            <m:mo stretchy="false">(</m:mo>
                            <m:mrow>
                              <m:mi>N</m:mi>
                              <m:mo stretchy="false">−</m:mo>
                              <m:mn>1</m:mn>
                            </m:mrow>
                            <m:mo stretchy="false">)</m:mo>
                            <m:mrow/>
                          </m:mrow>
                        </m:mtd>
                        <m:mtd>
                          <m:mrow>
                            <m:mi>x</m:mi>
                            <m:mo stretchy="false">(</m:mo>
                            <m:mrow>
                              <m:mi>N</m:mi>
                              <m:mo stretchy="false">−</m:mo>
                              <m:mn>2</m:mn>
                            </m:mrow>
                            <m:mo stretchy="false">)</m:mo>
                            <m:mrow/>
                          </m:mrow>
                        </m:mtd>
                        <m:mtd>
                          <m:mrow>
                            <m:mo stretchy="false">…</m:mo>
                            <m:mrow/>
                          </m:mrow>
                        </m:mtd>
                        <m:mtd>
                          <m:mrow>
                            <m:mi>x</m:mi>
                            <m:mrow>
                              <m:mrow>
                                <m:mo stretchy="false">(</m:mo>
                                <m:mo stretchy="false">−</m:mo>
                                <m:mi>N</m:mi>
                              </m:mrow>
                              <m:mo stretchy="false">+</m:mo>
                              <m:mn>1</m:mn>
                            </m:mrow>
                            <m:mo stretchy="false">)</m:mo>
                            <m:mrow/>
                          </m:mrow>
                        </m:mtd>
                        <m:mtd>
                          <m:mrow>
                            <m:mi>x</m:mi>
                            <m:mrow>
                              <m:mo stretchy="false">(</m:mo>
                              <m:mo stretchy="false">−</m:mo>
                              <m:mi>N</m:mi>
                            </m:mrow>
                            <m:mo stretchy="false">)</m:mo>
                            <m:mrow/>
                          </m:mrow>
                        </m:mtd>
                      </m:mtr>
                      <m:mtr>
                        <m:mtd>
                          <m:mrow>
                            <m:mo stretchy="false">⋮</m:mo>
                            <m:mrow/>
                          </m:mrow>
                        </m:mtd>
                        <m:mtd>
                          <m:mrow/>
                        </m:mtd>
                        <m:mtd>
                          <m:mrow/>
                        </m:mtd>
                        <m:mtd>
                          <m:mrow>
                            <m:mo stretchy="false">⋮</m:mo>
                            <m:mrow/>
                          </m:mrow>
                        </m:mtd>
                        <m:mtd>
                          <m:mrow/>
                        </m:mtd>
                        <m:mtd>
                          <m:mrow>
                            <m:mo stretchy="false">⋮</m:mo>
                            <m:mrow/>
                          </m:mrow>
                        </m:mtd>
                      </m:mtr>
                      <m:mtr>
                        <m:mtd>
                          <m:mrow>
                            <m:mn>0</m:mn>
                            <m:mrow/>
                          </m:mrow>
                        </m:mtd>
                        <m:mtd>
                          <m:mrow>
                            <m:mn>0</m:mn>
                            <m:mrow/>
                          </m:mrow>
                        </m:mtd>
                        <m:mtd>
                          <m:mrow>
                            <m:mn>0</m:mn>
                            <m:mrow/>
                          </m:mrow>
                        </m:mtd>
                        <m:mtd>
                          <m:mrow>
                            <m:mo stretchy="false">…</m:mo>
                            <m:mrow/>
                          </m:mrow>
                        </m:mtd>
                        <m:mtd>
                          <m:mrow>
                            <m:mi>x</m:mi>
                            <m:mo stretchy="false">(</m:mo>
                            <m:mi>N</m:mi>
                            <m:mo stretchy="false">)</m:mo>
                            <m:mrow/>
                          </m:mrow>
                        </m:mtd>
                        <m:mtd>
                          <m:mrow>
                            <m:mi>x</m:mi>
                            <m:mo stretchy="false">(</m:mo>
                            <m:mrow>
                              <m:mi>N</m:mi>
                              <m:mo stretchy="false">−</m:mo>
                              <m:mn>1</m:mn>
                            </m:mrow>
                            <m:mo stretchy="false">)</m:mo>
                            <m:mrow/>
                          </m:mrow>
                        </m:mtd>
                      </m:mtr>
                      <m:mtr>
                        <m:mtd>
                          <m:mrow>
                            <m:mn>0</m:mn>
                            <m:mrow/>
                          </m:mrow>
                        </m:mtd>
                        <m:mtd>
                          <m:mrow>
                            <m:mn>0</m:mn>
                            <m:mrow/>
                          </m:mrow>
                        </m:mtd>
                        <m:mtd>
                          <m:mrow>
                            <m:mn>0</m:mn>
                            <m:mrow/>
                          </m:mrow>
                        </m:mtd>
                        <m:mtd>
                          <m:mrow>
                            <m:mo stretchy="false">…</m:mo>
                            <m:mrow/>
                          </m:mrow>
                        </m:mtd>
                        <m:mtd>
                          <m:mrow>
                            <m:mn>0</m:mn>
                            <m:mrow/>
                          </m:mrow>
                        </m:mtd>
                        <m:mtd>
                          <m:mrow>
                            <m:mi>x</m:mi>
                            <m:mo stretchy="false">(</m:mo>
                            <m:mi>N</m:mi>
                            <m:mo stretchy="false">)</m:mo>
                            <m:mrow/>
                          </m:mrow>
                        </m:mtd>
                      </m:mtr>
                    </m:mtable>
                  </m:mfenced>
                </m:mrow>
              </m:mrow>
            </m:mstyle>
            <m:mrow/>
          </m:mrow>
          <m:annotation encoding="StarMath 5.0"> size 12{x= left [ matrix {
x \(  - N \)  {} # 0 {} # 0 {} #  dotslow  {} # 0 {} # 0 {} ##
x \(  - N+1 \)  {} # x \(  - N \)  {} # 0 {} #  dotslow  {} #  dotslow  {} #  dotslow  {} ##
 dotsvert  {} #  {} #  {} #  dotsvert  {} #  {} #  dotsvert  {} ##
x \( N \)  {} # x \( N - 1 \)  {} # x \( N - 2 \)  {} #  dotslow  {} # x \(  - N+1 \)  {} # x \(  - N \)  {} ##
 dotsvert  {} #  {} #  {} #  dotsvert  {} #  {} #  dotsvert  {} ##
0 {} # 0 {} # 0 {} #  dotslow  {} # x \( N \)  {} # x \( N - 1 \)  {} ##
0 {} # 0 {} # 0 {} #  dotslow  {} # 0 {} # x \( N \) {}
}  right ]} {}</m:annotation>
        </m:semantics>
      </m:math>
    </para>
    <para id="id10143444">We can describe the relationship among 
<m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:mrow><m:mi>z</m:mi><m:mo stretchy="false">(</m:mo><m:mi>k</m:mi><m:mo stretchy="false">)</m:mo></m:mrow></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{z \( k \) } {}</m:annotation></m:semantics></m:math>, 
<m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:mrow><m:mi>x</m:mi><m:mo stretchy="false">(</m:mo><m:mi>k</m:mi><m:mo stretchy="false">)</m:mo></m:mrow></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{x \( k \) } {}</m:annotation></m:semantics></m:math> and 
<m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:msub><m:mi>c</m:mi><m:mstyle fontsize="8pt"><m:mrow><m:mi>n</m:mi></m:mrow></m:mstyle></m:msub></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{c rSub { size 8{n} } } {}</m:annotation></m:semantics></m:math> more compactly as</para>
    <para id="id10724748"><m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:mrow><m:mrow><m:mi>z</m:mi><m:mo stretchy="false">=</m:mo><m:mi>x</m:mi></m:mrow><m:mtext>.</m:mtext><m:mi>c</m:mi></m:mrow></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{z=x "." c} {}</m:annotation></m:semantics></m:math>(3a)</para>
    <para id="id10032476">Whenever the matrix x is square, we can find c by solving the following equation:</para>
    <para id="id10032481"><m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:mrow><m:mrow><m:mi>c</m:mi><m:mo stretchy="false">=</m:mo><m:msup><m:mi>x</m:mi><m:mstyle fontsize="8pt"><m:mrow><m:mrow><m:mo stretchy="false">−</m:mo><m:mn>1</m:mn></m:mrow></m:mrow></m:mstyle></m:msup></m:mrow><m:mi>z</m:mi></m:mrow></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{c=x rSup { size 8{ - 1} } z} {}</m:annotation></m:semantics></m:math>(3b)</para>
    <para id="id10237976">Notice that the index k was arbitrarily chosen to allow for 
<m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:mrow><m:mn>4N</m:mn><m:mo stretchy="false">+</m:mo><m:mn>1</m:mn></m:mrow></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{4N+1} {}</m:annotation></m:semantics></m:math> sample points. The vectors z and c have dimensions 
<m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:mrow><m:mn>4N</m:mn><m:mo stretchy="false">+</m:mo><m:mn>1</m:mn></m:mrow></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{4N+1} {}</m:annotation></m:semantics></m:math> and 
<m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:mrow><m:mn>2N</m:mn><m:mo stretchy="false">+</m:mo><m:mn>1</m:mn></m:mrow></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{2N+1} {}</m:annotation></m:semantics></m:math>. Such equations are referred to as an overdetermined set. This problem can be solved in deterministic way known as the zero-forcing solution, or, in a statistical way, known as the <emphasis>minimum mean-square error (MMSE)</emphasis> solution.</para>
    <para id="id10761091"><term>Zero-Forcing Solution</term></para>
    <para id="id10761095">At first, by disposing top N rows and bottom N rows, matrix x is transformed into a square matrix of dimension 
<m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:mrow><m:mn>2N</m:mn><m:mo stretchy="false">+</m:mo><m:mn>1</m:mn></m:mrow></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{2N+1} {}</m:annotation></m:semantics></m:math> by 
<m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:mrow><m:mn>2N</m:mn><m:mo stretchy="false">+</m:mo><m:mn>1</m:mn></m:mrow></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{2N+1} {}</m:annotation></m:semantics></m:math>. Then equation 
<m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:mrow><m:mrow><m:mi>c</m:mi><m:mo stretchy="false">=</m:mo><m:msup><m:mi>x</m:mi><m:mstyle fontsize="8pt"><m:mrow><m:mrow><m:mo stretchy="false">−</m:mo><m:mn>1</m:mn></m:mrow></m:mrow></m:mstyle></m:msup></m:mrow><m:mi>z</m:mi></m:mrow></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{c=x rSup { size 8{ - 1} } z} {}</m:annotation></m:semantics></m:math> is used to solve the 
<m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:mrow><m:mn>2N</m:mn><m:mo stretchy="false">+</m:mo><m:mn>1</m:mn></m:mrow></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{2N+1} {}</m:annotation></m:semantics></m:math> simultaneous equations for the set of 
<m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:mrow><m:mn>2N</m:mn><m:mo stretchy="false">+</m:mo><m:mn>1</m:mn></m:mrow></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{2N+1} {}</m:annotation></m:semantics></m:math> weights 
<m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:msub><m:mi>c</m:mi><m:mstyle fontsize="8pt"><m:mrow><m:mi>n</m:mi></m:mrow></m:mstyle></m:msub></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{c rSub { size 8{n} } } {}</m:annotation></m:semantics></m:math>. This solution minimizes the peak ISI distortion by selecting the 
<m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:msub><m:mi>C</m:mi><m:mstyle fontsize="8pt"><m:mrow><m:mi>n</m:mi></m:mrow></m:mstyle></m:msub></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{C rSub { size 8{n} } } {}</m:annotation></m:semantics></m:math> weight so that the equalizer output is forced to zero at N sample points on either side of the desired pulse.</para>
    <para id="id7382170"><m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:mrow><m:mi>z</m:mi><m:mo stretchy="false">(</m:mo><m:mi>k</m:mi><m:mrow><m:mo stretchy="false">)</m:mo><m:mo stretchy="false">=</m:mo><m:mrow><m:mo stretchy="true">{</m:mo><m:mtable><m:mtr><m:mtd><m:mrow><m:mn>1</m:mn><m:mrow/></m:mrow></m:mtd><m:mtd><m:mrow><m:mrow><m:mi>k</m:mi><m:mo stretchy="false">=</m:mo><m:mn>0</m:mn></m:mrow><m:mrow/></m:mrow></m:mtd></m:mtr><m:mtr><m:mtd><m:mrow><m:mn>0</m:mn><m:mrow/></m:mrow></m:mtd><m:mtd><m:mrow><m:mrow><m:mi>k</m:mi><m:mo stretchy="false">=</m:mo><m:mrow><m:mrow><m:mrow><m:mo stretchy="false">±</m:mo><m:mn>1,</m:mn></m:mrow><m:mo stretchy="false">±</m:mo><m:mn>2,</m:mn></m:mrow><m:mo stretchy="false">±</m:mo><m:mn>3</m:mn></m:mrow></m:mrow><m:mrow/></m:mrow></m:mtd></m:mtr></m:mtable></m:mrow></m:mrow></m:mrow></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{z \( k \) = left lbrace  matrix {
1 {} # k=0 {} ##
0 {} # k= +- 1, +- 2, +- 3{}
}  right none } {}</m:annotation></m:semantics></m:math>(4)</para>
    <para id="id10546323">For such an equalizer with finite length, the peak distortion is guaranteed to be minimized only if the eye pattern is initially open. However, for high-speed transmission and channels introducing much ISI, the eye is often closed before equalization. Since the zero-forcing equalizer neglects the effect of noise, it is not always the best system solution.</para>
    <para id="id7116896"><term>Minimum MSE Solution</term></para>
    <para id="id7116900">A more robust equalizer is obtained if the 
<m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:msub><m:mi>c</m:mi><m:mstyle fontsize="8pt"><m:mrow><m:mi>n</m:mi></m:mrow></m:mstyle></m:msub></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{c rSub { size 8{n} } } {}</m:annotation></m:semantics></m:math> tap weights are chose to minimize the mean-square error (MSE) of all the ISI term plus the noise power at the out put of the equalizer. MSE is defined as the expected value of the squared difference between the desire data symbol and the estimated data symbol.</para>
    <para id="id9971558">By multiplying both sides of equation (4) by 
<m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:msup><m:mi>x</m:mi><m:mstyle fontsize="8pt"><m:mrow><m:mi>T</m:mi></m:mrow></m:mstyle></m:msup></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{x rSup { size 8{T} } } {}</m:annotation></m:semantics></m:math>, we have</para>
    <para id="id11236942"><m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:mrow><m:msup><m:mi>x</m:mi><m:mstyle fontsize="8pt"><m:mrow><m:mi>T</m:mi></m:mrow></m:mstyle></m:msup><m:mrow><m:mi>z</m:mi><m:mo stretchy="false">=</m:mo><m:msup><m:mi>x</m:mi><m:mstyle fontsize="8pt"><m:mrow><m:mi>T</m:mi></m:mrow></m:mstyle></m:msup></m:mrow><m:mstyle fontstyle="italic"><m:mrow><m:mtext>xc</m:mtext></m:mrow></m:mstyle></m:mrow></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{x rSup { size 8{T} } z=x rSup { size 8{T} }  ital "xc"} {}</m:annotation></m:semantics></m:math>(5)</para>
    <para id="id10582952">And</para>
    <para id="id10582956"><m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:mrow><m:mrow><m:msub><m:mi>R</m:mi><m:mstyle fontsize="8pt"><m:mrow><m:mstyle fontstyle="italic"><m:mrow><m:mtext>xz</m:mtext></m:mrow></m:mstyle></m:mrow></m:mstyle></m:msub><m:mo stretchy="false">=</m:mo><m:msub><m:mi>R</m:mi><m:mstyle fontsize="8pt"><m:mrow><m:mstyle fontstyle="italic"><m:mrow><m:mtext>xx</m:mtext></m:mrow></m:mstyle></m:mrow></m:mstyle></m:msub></m:mrow><m:mi>c</m:mi></m:mrow></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{R rSub { size 8{ ital "xz"} } =R rSub { size 8{ ital "xx"} } c} {}</m:annotation></m:semantics></m:math> (6)</para>
    <para id="id10969714">Where 
<m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:mrow><m:mrow><m:msub><m:mi>R</m:mi><m:mstyle fontsize="8pt"><m:mrow><m:mstyle fontstyle="italic"><m:mrow><m:mtext>xz</m:mtext></m:mrow></m:mstyle></m:mrow></m:mstyle></m:msub><m:mo stretchy="false">=</m:mo><m:msup><m:mi>x</m:mi><m:mstyle fontsize="8pt"><m:mrow><m:mi>T</m:mi></m:mrow></m:mstyle></m:msup></m:mrow><m:mi>z</m:mi></m:mrow></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{R rSub { size 8{ ital "xz"} } =x rSup { size 8{T} } z} {}</m:annotation></m:semantics></m:math> is called the cross-correlation vector and 
<m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:mrow><m:mrow><m:msub><m:mi>R</m:mi><m:mstyle fontsize="8pt"><m:mrow><m:mstyle fontstyle="italic"><m:mrow><m:mtext>xx</m:mtext></m:mrow></m:mstyle></m:mrow></m:mstyle></m:msub><m:mo stretchy="false">=</m:mo><m:msup><m:mi>x</m:mi><m:mstyle fontsize="8pt"><m:mrow><m:mi>T</m:mi></m:mrow></m:mstyle></m:msup></m:mrow><m:mi>x</m:mi></m:mrow></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{R rSub { size 8{ ital "xx"} } =x rSup { size 8{T} } x} {}</m:annotation></m:semantics></m:math> is call the autocorrelation matrix of the input noisy signal. In practice, 
<m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:msub><m:mi>R</m:mi><m:mstyle fontsize="8pt"><m:mrow><m:mstyle fontstyle="italic"><m:mrow><m:mtext>xz</m:mtext></m:mrow></m:mstyle></m:mrow></m:mstyle></m:msub></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{R rSub { size 8{ ital "xz"} } } {}</m:annotation></m:semantics></m:math> and 
<m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:msub><m:mi>R</m:mi><m:mstyle fontsize="8pt"><m:mrow><m:mstyle fontstyle="italic"><m:mrow><m:mtext>xx</m:mtext></m:mrow></m:mstyle></m:mrow></m:mstyle></m:msub></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{R rSub { size 8{ ital "xx"} } } {}</m:annotation></m:semantics></m:math> are unknown, but they can be approximated by transmitting a test signal and using time average estimated to solve for the tap weights from equation (6) as follows:</para>
    <para id="id9763749">
      <m:math>
        <m:semantics>
          <m:mrow>
            <m:mstyle fontsize="12pt">
              <m:mrow>
                <m:mrow>
                  <m:mrow>
                    <m:mi>c</m:mi>
                    <m:mo stretchy="false">=</m:mo>
                    <m:msubsup>
                      <m:mi>R</m:mi>
                      <m:mstyle fontsize="8pt">
                        <m:mrow>
                          <m:mstyle fontstyle="italic">
                            <m:mrow>
                              <m:mtext>xx</m:mtext>
                            </m:mrow>
                          </m:mstyle>
                        </m:mrow>
                      </m:mstyle>
                      <m:mstyle fontsize="8pt">
                        <m:mrow>
                          <m:mrow>
                            <m:mo stretchy="false">−</m:mo>
                            <m:mn>1</m:mn>
                          </m:mrow>
                        </m:mrow>
                      </m:mstyle>
                    </m:msubsup>
                  </m:mrow>
                  <m:msub>
                    <m:mi>R</m:mi>
                    <m:mstyle fontsize="8pt">
                      <m:mrow>
                        <m:mstyle fontstyle="italic">
                          <m:mrow>
                            <m:mtext>xz</m:mtext>
                          </m:mrow>
                        </m:mstyle>
                      </m:mrow>
                    </m:mstyle>
                  </m:msub>
                </m:mrow>
              </m:mrow>
            </m:mstyle>
            <m:mrow/>
          </m:mrow>
          <m:annotation encoding="StarMath 5.0"> size 12{c=R rSub { size 8{ ital "xx"} }  rSup { size 8{ - 1} } R rSub { size 8{ ital "xz"} } } {}</m:annotation>
        </m:semantics>
      </m:math>
    </para>
    <para id="id10739637">Most high-speed telephone-line modems use an MSE weight criterion because it is superior to a zero-forcing criterion; it is more robust in the presence of noise and large ISI</para>
  </content>
</document>